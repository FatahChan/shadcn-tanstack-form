import { componentMetadataSchema } from "@/schemas/component-meta-data";
import { registrySchema } from "@/schemas/registry";
import { registryItemSchema } from "@/schemas/registry-item";
import { FileSystem, Path } from "@effect/platform";
import {
  NodeContext,
  NodeFileSystem,
  NodeRuntime,
} from "@effect/platform-node";
import { Console, Data, Effect, Match, Stream } from "effect";
import type { ZodType, z } from "zod";

const blockTemplate = ({
  blockSlug,
}: {
  blockSlug: string;
}) => `// this file is generated by src/scripts/watcher.effect.ts
import Form from "@/components/blocks/${blockSlug}";
import { createFileRoute } from "@tanstack/react-router";
export const Route = createFileRoute("/preview/${blockSlug}")({
  component: () => (
    <div className="flex min-h-screen w-full items-center justify-center py-4">
      <Form onSubmit={(data) => console.log(data)} />
    </div>
  ),
});
`;
const componentTemplate = ({
  componentSlug,
}: {
  componentSlug: string;
}) => `// this file is generated by src/scripts/watcher.effect.ts
import Component from "@/components/form-fields/${componentSlug}";
import { createFileRoute } from "@tanstack/react-router";
export const Route = createFileRoute("/preview/${componentSlug}")({
  component: () => (
    <div className="flex min-h-screen w-full items-center justify-center py-4">
      <Component className="w-60" />
    </div>
  ),
});
`;
class JsonParseError extends Data.Error<{
  error?: unknown;
  jsonString?: string;
}> {}
class SchemaParseError extends Data.Error<{
  error?: unknown;
  schema: ZodType;
  object: unknown;
}> {}
function parseJson(jsonString: string) {
  return Effect.try({
    try: () => JSON.parse(jsonString),
    catch: (error) => new JsonParseError({ error, jsonString }),
  });
}
function parseSchema<S extends z.ZodType>(
  object: Record<string, unknown>,
  schema: S,
) {
  return Effect.try({
    try: () => schema.parse(object) as z.infer<S>,
    catch: (error) => new SchemaParseError({ error, schema, object }),
  });
}

function parseJsonSchema<S extends z.ZodType>(jsonString: string, schema: S) {
  return parseJson(jsonString).pipe(
    Effect.flatMap((json) => parseSchema(json, schema)),
  );
}

const getBlocksPath = () =>
  Effect.gen(function* () {
    const path = yield* Path.Path;
    return path.join(process.cwd(), "src", "components", "blocks");
  });

const getComponentsPath = () =>
  Effect.gen(function* () {
    const path = yield* Path.Path;
    return path.join(process.cwd(), "src", "components", "form-fields");
  });

function createRegistryItem(
  componentMetadata: z.infer<typeof componentMetadataSchema>,
  slug: string,
  type: "registry:block" | "registry:component",
) {
  return Effect.gen(function* () {
    const path = yield* Path.Path;
    const fs = yield* FileSystem.FileSystem;
    const registryPath = yield* Match.value(type).pipe(
      Match.when("registry:block", () => getBlocksPath()),
      Match.when("registry:component", () => getComponentsPath()),
      Match.exhaustive,
    );
    const relativePath = path.relative(process.cwd(), registryPath);

    const content = yield* fs.readFileString(
      path.join(registryPath, `${slug}.tsx`),
    );

    const registryItem = yield* Effect.succeed({
      name: slug,
      type,
      title: componentMetadata.title,
      description: componentMetadata.description,
      files: [
        {
          type,
          path: `${relativePath}/${slug}.tsx`,
          content,
        },
      ],
      categories: componentMetadata.categories,
      dependencies: componentMetadata.dependencies,
      registryDependencies: componentMetadata.registryDependencies,
    });
    return yield* parseSchema(registryItem, registryItemSchema);
  });
}

function updateRegistry(
  registryJson: z.infer<typeof registrySchema>,
  registryItem: z.infer<typeof registryItemSchema>,
) {
  return Effect.gen(function* () {
    const items = registryJson.items;
    const itemIndex = items.findIndex(
      (item) => item.name === registryItem.name,
    );
    if (itemIndex !== -1) {
      items.splice(itemIndex, 1);
      items.splice(itemIndex, 0, registryItem);
    } else {
      items.push(registryItem);
    }
    registryJson.items = items;
    return registryJson;
  });
}
function writeRegistry(registryJson: z.infer<typeof registrySchema>) {
  return Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;
    const registryPath = path.join(process.cwd(), "registry.json");
    yield* fs.writeFileString(
      registryPath,
      JSON.stringify(registryJson, null, 2),
    );
  });
}
const updateBlockPreviewAction = (blockSlug: string) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;

    yield* Console.log("Updating block preview", blockSlug);
    const previewPath = path.join(process.cwd(), "src", "routes", "preview");
    yield* fs.writeFileString(
      path.join(previewPath, `${blockSlug}.tsx`),
      blockTemplate({ blockSlug }),
    );
    yield* Console.log("Updated block preview", blockSlug);
  });

const updateComponentPreviewAction = (componentSlug: string) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;

    yield* Console.log("Updating component preview", componentSlug);
    const previewPath = path.join(process.cwd(), "src", "routes", "preview");
    yield* fs.writeFileString(
      path.join(previewPath, `${componentSlug}.tsx`),
      componentTemplate({ componentSlug }),
    );
    yield* Console.log("Updated component preview", componentSlug);
  });

const updateBlockRegistryAction = (slug: string) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;
    const blocksPath = yield* getBlocksPath();
    const registryPath = path.join(process.cwd(), "registry.json");
    const blockJson = yield* fs.readFileString(
      path.join(blocksPath, `${slug}.json`),
    );

    const blockMetadata = yield* parseJsonSchema(
      blockJson,
      componentMetadataSchema,
    );

    yield* Console.log("Updating registry", slug);

    const registryJsonString = yield* fs.readFileString(registryPath);
    const registryJson = yield* parseJsonSchema(
      registryJsonString,
      registrySchema,
    );
    const registryItem = yield* createRegistryItem(
      blockMetadata,
      slug,
      "registry:block",
    );
    const updatedRegistryJson = yield* updateRegistry(
      registryJson,
      registryItem,
    );
    yield* writeRegistry(updatedRegistryJson);
    yield* Console.log("Updated registry", slug);
  });

const updateComponentRegistryAction = (slug: string) => {
  return Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;
    const componentsPath = yield* getComponentsPath();
    const registryPath = path.join(process.cwd(), "registry.json");
    const componentJson = yield* fs.readFileString(
      path.join(componentsPath, `${slug}.json`),
    );

    const componentMetadata = yield* parseJsonSchema(
      componentJson,
      componentMetadataSchema,
    );

    yield* Console.log("Updating registry", slug);

    const registryJsonString = yield* fs.readFileString(registryPath);
    const registryJson = yield* parseJsonSchema(
      registryJsonString,
      registrySchema,
    );
    const registryItem = yield* createRegistryItem(
      componentMetadata,
      slug,
      "registry:component",
    );
    const updatedRegistryJson = yield* updateRegistry(
      registryJson,
      registryItem,
    );
    yield* writeRegistry(updatedRegistryJson);
    yield* Console.log("Updated registry", slug);
  });
};

const watcher = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;
  const blocksPath = yield* getBlocksPath();

  const watchBlockStream = fs
    .watch(blocksPath)
    .pipe(Stream.map((event) => ({ from: blocksPath, ...event })));

  const componentsPath = yield* getComponentsPath();
  const watchComponentStream = fs
    .watch(componentsPath)
    .pipe(Stream.map((event) => ({ from: componentsPath, ...event })));

  const watchStream = Stream.merge(watchBlockStream, watchComponentStream);

  yield* Stream.runForEach(watchStream, (event) =>
    Effect.gen(function* () {
      yield* Console.log("File changed", event);
      const slug = event.path.split(".").shift();
      if (!slug) return;

      if (event.from === blocksPath) {
        yield* Effect.all([
          updateBlockPreviewAction(slug),
          updateBlockRegistryAction(slug),
        ]);
      }
      if (event.from === componentsPath) {
        yield* Effect.all([
          updateComponentPreviewAction(slug),
          updateComponentRegistryAction(slug),
        ]);
      }
    }),
  ).pipe(Effect.catchAll(Console.error));
});

const updateBlocksAll = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;

  const blocksPath = yield* getBlocksPath();

  const files = yield* fs.readDirectory(blocksPath);
  const slugs = files
    .filter((file) => file.endsWith(".tsx"))
    .map((file) => file.split(".")[0]);

  yield* Effect.all(
    slugs.flatMap((slug) => [
      updateBlockPreviewAction(slug),
      updateBlockRegistryAction(slug),
    ]),
  ).pipe(Effect.catchAll(Console.error));
});

const updateComponentsAll = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;

  const componentsPath = yield* getComponentsPath();

  const files = yield* fs.readDirectory(componentsPath);
  const slugs = files
    .filter((file) => file.endsWith(".tsx"))
    .map((file) => file.split(".")[0]);

  yield* Effect.all(
    slugs.flatMap((slug) => [
      updateComponentPreviewAction(slug),
      updateComponentRegistryAction(slug),
    ]),
  ).pipe(Effect.catchAll(Console.error));
});

const program = Effect.gen(function* () {
  yield* updateBlocksAll;
  yield* updateComponentsAll;
  yield* watcher;
});

program.pipe(
  Effect.provide(NodeContext.layer),
  Effect.provide(NodeFileSystem.layer),
  NodeRuntime.runMain,
);
