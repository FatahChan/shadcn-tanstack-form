import { blockMetadataSchema } from "@/schemas/block-meta-data";
import { registrySchema } from "@/schemas/registry";
import { registryItemSchema } from "@/schemas/registry-item";
import { FileSystem, Path } from "@effect/platform";
import {
  NodeContext,
  NodeFileSystem,
  NodeRuntime,
} from "@effect/platform-node";
import { Console, Data, Effect, Stream } from "effect";
import type { ZodType, z } from "zod";

const template = ({
  blockSlug,
}: {
  blockSlug: string;
}) => `// this file is generated by src/scripts/watcher.effect.ts
import Form from "@/registry/new-york/blocks/${blockSlug}";
import { createFileRoute } from "@tanstack/react-router";
export const Route = createFileRoute("/preview/${blockSlug}")({
  component: () => <Form onSubmit={(data) => console.log(data)} />,
});
`;
class JsonParseError extends Data.Error<{
  error?: unknown;
  jsonString?: string;
}> {}
class SchemaParseError extends Data.Error<{
  error?: unknown;
  schema: ZodType;
  object: unknown;
}> {}
function parseJson(jsonString: string) {
  return Effect.try({
    try: () => JSON.parse(jsonString),
    catch: (error) => new JsonParseError({ error, jsonString }),
  });
}
function parseSchema<S extends z.ZodType>(
  object: Record<string, unknown>,
  schema: S,
) {
  return Effect.try({
    try: () => schema.parse(object) as z.infer<S>,
    catch: (error) => new SchemaParseError({ error, schema, object }),
  });
}

function parseJsonSchema<S extends z.ZodType>(jsonString: string, schema: S) {
  return parseJson(jsonString).pipe(
    Effect.flatMap((json) => parseSchema(json, schema)),
  );
}

const getBlocksPath = () =>
  Effect.gen(function* () {
    const path = yield* Path.Path;
    const blocksPath = path.join(
      process.cwd(),
      "src",
      "registry",
      "new-york",
      "blocks",
    );
    return blocksPath;
  });
function createRegistryItem(
  blockMetadata: z.infer<typeof blockMetadataSchema>,
  code: string,
  blockSlug: string,
) {
  return Effect.succeed({
    name: blockSlug,
    type: "registry:block",
    title: blockMetadata.title,
    description: blockMetadata.description,
    files: [
      {
        type: "registry:block",
        path: `src/registry/new-york/blocks/${blockSlug}.tsx`,
        content: code,
      },
    ],
    categories: blockMetadata.categories,
    dependencies: blockMetadata.dependencies,
    registryDependencies: blockMetadata.registryDependencies,
  }).pipe(
    Effect.flatMap((registryItem) =>
      parseSchema(registryItem, registryItemSchema),
    ),
  );
}

function updateRegistry(
  registryJson: z.infer<typeof registrySchema>,
  registryItem: z.infer<typeof registryItemSchema>,
) {
  return Effect.gen(function* () {
    const items = registryJson.items;
    const itemIndex = items.findIndex(
      (item) => item.name === registryItem.name,
    );
    if (itemIndex !== -1) {
      items.splice(itemIndex, 1);
    }
    items.push(registryItem);
    registryJson.items = items;
    return registryJson;
  });
}
function writeRegistry(registryJson: z.infer<typeof registrySchema>) {
  return Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;
    const registryPath = path.join(process.cwd(), "registry.json");
    yield* fs.writeFileString(
      registryPath,
      JSON.stringify(registryJson, null, 2),
    );
  });
}
const updatePreviewAction = (blockSlug: string) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;

    yield* Console.log("Updating preview");
    const previewPath = path.join(process.cwd(), "src", "routes", "preview");
    yield* fs.writeFileString(
      path.join(previewPath, `${blockSlug}.tsx`),
      template({ blockSlug }),
    );
    yield* Console.log("Updated preview");
  });

const updateRegistryAction = (blockSlug: string) =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;
    const blocksPath = yield* getBlocksPath();
    const registryPath = path.join(process.cwd(), "registry.json");
    const blockJson = yield* fs.readFileString(
      path.join(blocksPath, `${blockSlug}.json`),
    );
    const code = yield* fs.readFileString(
      path.join(blocksPath, `${blockSlug}.tsx`),
    );

    const blockMetadata = yield* parseJsonSchema(
      blockJson,
      blockMetadataSchema,
    );

    yield* Console.log("Updating registry");

    const registryJsonString = yield* fs.readFileString(registryPath);
    const registryJson = yield* parseJsonSchema(
      registryJsonString,
      registrySchema,
    );
    const registryItem = yield* createRegistryItem(
      blockMetadata,
      code,
      blockSlug,
    );
    const updatedRegistryJson = yield* updateRegistry(
      registryJson,
      registryItem,
    );
    yield* writeRegistry(updatedRegistryJson);
    yield* Console.log("Updated registry");
  });

const watcher = Effect.gen(function* () {
  const path = yield* Path.Path;
  const fs = yield* FileSystem.FileSystem;
  const blocksPath = yield* getBlocksPath();

  const watchStream = fs.watch(blocksPath);

  yield* Stream.runForEach(watchStream, (event) =>
    Effect.gen(function* () {
      const blockSlug = path.basename(
        path.basename(event.path, ".tsx"),
        ".json",
      );
      yield* Effect.all([
        updatePreviewAction(blockSlug),
        updateRegistryAction(blockSlug),
      ]);
    }),
  ).pipe(
    Effect.catchAll((error) => {
      return Console.error(error);
    }),
  );
});
const program = Effect.gen(function* () {
  const path = yield* Path.Path;
  const fs = yield* FileSystem.FileSystem;

  const blocksPath = yield* getBlocksPath();

  const files = yield* fs.readDirectory(blocksPath);
  const slugs = files
    .filter((file) => file.endsWith(".tsx"))
    .map((file) => path.basename(file, ".tsx"));

  yield* Effect.all(
    slugs.map((slug) =>
      Effect.all([updatePreviewAction(slug), updateRegistryAction(slug)]),
    ),
  ).pipe(
    Effect.catchAll((error) => {
      return Console.error(error);
    }),
  );
  yield* watcher;
});

program.pipe(
  Effect.provide(NodeContext.layer),
  Effect.provide(NodeFileSystem.layer),
  NodeRuntime.runMain,
);
