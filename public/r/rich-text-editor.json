{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "rich-text-editor",
  "type": "registry:component",
  "title": "Rich Text Editor",
  "description": "A Rich Text Editor component",
  "registryDependencies": [
    "textarea"
  ],
  "files": [
    {
      "path": "src/components/form-fields/rich-text-editor.tsx",
      "content": "import { cn } from \"@/lib/utils\";\nimport {\n  BoldIcon,\n  ItalicIcon,\n  ListIcon,\n  ListOrderedIcon,\n  StrikethroughIcon,\n  UnderlineIcon,\n} from \"lucide-react\";\nimport Quill, { type QuillOptions } from \"quill/core\";\nimport \"quill/dist/quill.snow.css\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { ToggleGroup, ToggleGroupItem } from \"@/components/ui/toggle-group\";\nimport {\n  type HtmlHTMLAttributes,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\ninterface RichTextEditorProps\n  extends Omit<HtmlHTMLAttributes<HTMLDivElement>, \"value\" | \"onChange\"> {\n  quillOptions?: QuillOptions;\n  value?: string;\n  onChange?: (value: string) => void;\n}\n\nconst EditorContext = createContext<{\n  editorContainerRef: React.RefObject<HTMLDivElement | null>;\n  quill: Quill | null;\n  formats: { [key: string]: unknown };\n} | null>(null);\n\nconst RichTextEditorRoot = ({\n  children,\n  quillOptions,\n  value,\n  onChange,\n  ...props\n}: RichTextEditorProps) => {\n  const editorContainerRef = useRef<HTMLDivElement>(null);\n  const [quill, setQuill] = useState<Quill | null>(null);\n  useEffect(() => {\n    const editorContainer = editorContainerRef.current;\n    if (!editorContainer) {\n      throw new Error(\"editorContainer or toolbarContainer is not found\");\n    }\n    const quill = new Quill(editorContainer, {\n      ...quillOptions,\n      modules: {\n        ...quillOptions?.modules,\n      },\n    });\n\n    setQuill(quill);\n    return () => {\n      setQuill(null);\n      editorContainer.innerHTML = \"\";\n    };\n  }, [quillOptions]);\n\n  const [formats, setFormats] = useState<{ [key: string]: unknown }>({});\n  useEffect(() => {\n    if (!quill) return;\n    const updateFormats = () => {\n      const formats = quill.getFormat();\n      console.log(formats);\n      setFormats((prev) => {\n        if (JSON.stringify(prev) === JSON.stringify(formats)) return prev;\n        return formats;\n      });\n    };\n    for (const event of Object.values(Quill.events)) {\n      quill.on(event, updateFormats);\n    }\n    return () => {\n      for (const event of Object.values(Quill.events)) {\n        quill.off(event, updateFormats);\n      }\n    };\n  }, [quill]);\n\n  return (\n    <EditorContext.Provider\n      value={{\n        editorContainerRef,\n        quill,\n        formats,\n      }}\n    >\n      <div\n        className=\"prose grid min-w-3xl items-center justify-items-start gap-4\"\n        {...props}\n      >\n        {children}\n      </div>\n    </EditorContext.Provider>\n  );\n};\n\nconst HeaderSelect = () => {\n  const { quill, formats } = useEditorContext();\n\n  return (\n    <Select\n      defaultValue=\"0\"\n      value={formats.header?.toString() || \"0\"}\n      onValueChange={(value) => quill?.format(\"header\", Number(value))}\n    >\n      <SelectTrigger className=\"min-w-32\">\n        <SelectValue placeholder=\"Select a header\" />\n      </SelectTrigger>\n      <SelectContent>\n        <SelectItem value=\"1\">H1</SelectItem>\n        <SelectItem value=\"2\">H2</SelectItem>\n        <SelectItem value=\"3\">H3</SelectItem>\n        <SelectItem value=\"4\">H4</SelectItem>\n        <SelectItem value=\"0\">Normal</SelectItem>\n      </SelectContent>\n    </Select>\n  );\n};\n\nconst FormatToggle = () => {\n  const { quill, formats } = useEditorContext();\n\n  const selectedFormats = useMemo(() => {\n    return Object.keys(formats)\n      .filter((key) => [\"bold\", \"italic\", \"underline\", \"strike\"].includes(key))\n      .sort() as string[];\n  }, [formats]);\n\n  const handleFormatChange = useCallback(\n    (format: string) => {\n      if (!quill) return;\n      const formats = quill.getFormat();\n      console.log(formats);\n      if (formats[format] === true) {\n        quill.format(format, false);\n        return;\n      }\n      quill.format(format, true);\n    },\n    [quill],\n  );\n\n  return (\n    <ToggleGroup type=\"multiple\" value={selectedFormats} variant=\"outline\">\n      <ToggleGroupItem\n        value=\"bold\"\n        aria-label=\"bold\"\n        onClick={() => handleFormatChange(\"bold\")}\n      >\n        <BoldIcon />\n      </ToggleGroupItem>\n      <ToggleGroupItem\n        value=\"italic\"\n        aria-label=\"italic\"\n        onClick={() => handleFormatChange(\"italic\")}\n      >\n        <ItalicIcon />\n      </ToggleGroupItem>\n      <ToggleGroupItem\n        value=\"underline\"\n        aria-label=\"underline\"\n        onClick={() => handleFormatChange(\"underline\")}\n      >\n        <UnderlineIcon />\n      </ToggleGroupItem>\n      <ToggleGroupItem\n        value=\"strike\"\n        aria-label=\"strikethrough\"\n        onClick={() => handleFormatChange(\"strike\")}\n      >\n        <StrikethroughIcon />\n      </ToggleGroupItem>\n    </ToggleGroup>\n  );\n};\n\nconst ListToggle = () => {\n  const { quill, formats } = useEditorContext();\n\n  const handleFormatChange = useCallback(\n    (format: string, value: \"ordered\" | \"bullet\") => {\n      if (!quill) return;\n      const formats = quill.getFormat();\n      if (formats.list === value) {\n        quill.format(format, false);\n        return;\n      }\n      quill.format(format, value);\n    },\n    [quill],\n  );\n\n  return (\n    <ToggleGroup\n      type=\"single\"\n      value={(formats.list as \"bullet\" | \"ordered\" | undefined) ?? \"\"}\n      variant=\"outline\"\n    >\n      <ToggleGroupItem\n        value=\"bullet\"\n        aria-label=\"bullet-list\"\n        onClick={() => handleFormatChange(\"list\", \"bullet\")}\n      >\n        <ListIcon />\n      </ToggleGroupItem>\n      <ToggleGroupItem\n        value=\"ordered\"\n        aria-label=\"ordered-list\"\n        onClick={() => handleFormatChange(\"list\", \"ordered\")}\n      >\n        <ListOrderedIcon />\n      </ToggleGroupItem>\n    </ToggleGroup>\n  );\n};\n\nconst useEditorContext = () => {\n  const context = useContext(EditorContext);\n  if (!context) {\n    throw new Error(\"useEditorContext must be used within an EditorProvider\");\n  }\n  return context;\n};\n\nconst Editor = ({\n  className,\n  ...props\n}: HtmlHTMLAttributes<HTMLDivElement>) => {\n  const { editorContainerRef } = useEditorContext();\n  return (\n    <div\n      ref={editorContainerRef}\n      className={cn(\n        \"min-h-16 w-full rounded-md border border-input bg-transparent text-base shadow-xs outline-none transition-[color,box-shadow] placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:cursor-not-allowed disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 md:text-sm dark:bg-input/30 dark:aria-invalid:ring-destructive/40\",\n        className,\n      )}\n      {...props}\n    />\n  );\n};\n\nfunction RichTextEditor() {\n  const [value, setValue] = useState<string>(\"\");\n  useEffect(() => {\n    console.log(value);\n  }, [value]);\n  return (\n    <RichTextEditorRoot value={value} onChange={setValue}>\n      <div className=\"flex w-full gap-2\">\n        <HeaderSelect />\n        <FormatToggle />\n        <ListToggle />\n      </div>\n      <Editor />\n    </RichTextEditorRoot>\n  );\n}\n\nexport default RichTextEditor;\n",
      "type": "registry:component"
    }
  ],
  "categories": [
    "forms",
    "editor"
  ]
}